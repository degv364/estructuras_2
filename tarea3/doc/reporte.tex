\documentclass {article}

\usepackage[spanish]{babel}
\usepackage [T1]{fontenc}
\usepackage [utf8]{inputenc}
\usepackage {graphicx}
\usepackage{color}
\usepackage{xcolor}
\usepackage{verbatim}
\usepackage{tabls}
\usepackage[space]{grffile}
\usepackage{url}
\usepackage{float}
\usepackage{listingsutf8}
\usepackage[justification=centering]{caption}
\usepackage{subcaption}
\usepackage{multirow}
\usepackage{apacite}

\lstset{language=C++,
  frame=single,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  commentstyle=\color[rgb]{0,0.5,0}\ttfamily,
  morecomment=[l][\color{magenta}]{\#},
  literate=%
  {á}{{\'a}}1
  {í}{{\'i}}1
  {é}{{\'e}}1
  {ó}{{\'o}}1
  {ú}{{\'u}}1
  {ñ}{{\~n}}1
}


\begin {document}

\title{Tarea 3: Uso de Gem5}
\author{Daniel García Vaglio (B42781), Esteban Zamora Alvarado (B47769)}

\maketitle

\section{¿Qué es Gem5?}
\cite{opencv} %avoid compilation errors
La herramienta Gem5 consiste en una plataforma de software libre (licencia BSD) para la simulación
de sistemas computacionales basada en la ejecución de una serie de eventos discretos \cite{***}, los
cuales conforman la simulación temporal del sistema. Al ser modular y abierto, Gem5 permite
modificar, extender o reemplazar sus módulos para adaptarse a las necesidades del usuario, mediante
la exposición de la clase \texttt{SimObject}, con la cual se pueden crear nuevos objetos para
agregarlos al sistema de simulación.

Esta plataforma está orientada a la investigación en arquitecturas de computadoras, por lo que tiene
aplicaciones a nivel académico y en la industria, soportando arquitecturas como MIPS, ARM, Power,
SPARC y x86 \cite{***}. Con respecto al software de Gem5, el mismo está implementado principalmente
en C++ y Python, en donde el usuario escribe un script de configuración en Python para establecer
las condiciones de la simulación, las características del hardware simulado, el modelo de memoria y
procesamiento, entre otros \cite{***}.

Más específicamente, la ejecución de Gem5 utiliza el script de configuración establecido por el
usuario para correr cierto binario objetivo compilado para la arquitectura de interés, presentando
mediante la salida estándar cierta información sobre la simulación realizada y la salida propia del
binario objetivo, y mediante una serie de archivos, la lista de objetos de simulación creados y las
estadísticas de la simulación (tiempo de ejecución, uso de memoria, entre otros).

\subsection{Modos de simulación en Gem5}
Dentro de los modos de simulación disponibles en Gem5 se encuentra ``Full System Mode'', en el cual
se simula el sistema de hardware completo, lo cual comprende el CPU, la memoria, dispositivos de
entrada y salida (IO), entre otros; de forma que esta herramienta se comporta como un hypervisor
\cite{***}. Este modo permite entonces exponer los efectos de más bajo nivel sobre el rendimiento
del sistema computacional, asociados a la interacción del sistema operativo con el hardware, de
manera que el usuario incluso debe brindar una versión del kernel de Linux para ejecutarlo. Por otra
parte, en ``System-call Emulation Mode'' se simula el programa binario objetivo y la respuesta del
sistema operativo a dicho programa mediante llamadas de sistema, por lo que no se simula el efecto
del hardware subyacente.

\subsection{Modelos de CPU en Gem5}
Gem5 permite utilizar diferentes modelos de CPU para ejecutar las simulaciones, los cuales
comprenden diferentes niveles de complejidad a nivel arquitectónico (modelo del pipeline,
interacción con memoria, entre otros). En primer lugar, el modelo \texttt{SimpleCPU} es uno
puramente funcional con ejecución en orden, el cual es adecuado cuando no se requiere simular un
modelo más complejo. Más detalladamente, este modelo mantiene el estado arquitectónico del programa
mediante registros, permite ejecutar rutinas de interrupción, hacer solicitudes (``fetch'') a
memoria y actualizar el PC (``Program Counter'') al avanzar en la ejecución de las
instrucciones. Además \texttt{SimpleCPU} permite dos submodos, \texttt{AtomicSimpleCPU}, el cual
emplea accesos atómicos a memoria (solicitando y obteniendo los datos en una misma transacción), y
el \texttt{TimingSimpleCPU}, en el cual se realizar accesos a memoria temporizados (simula de forma
detallada las latencias de acceso a la jerarquía de memoria).


\section{Escenarios de prueba}

\subsection{Instalación}
Como se indica en las instrucciones, para instalar el simulador se emplea una máquina virtual de
Virtual Box, en Ubuntu 16.04 LTS. En la figura %ref fig
se muestran las especificaciones utilizadas par la realización de la tarea.

 
Luego para instalar gem5, lo primero que se debe hacer es instalar las dependencias. Como muchas de
ellas se encuentran en los repositorios denominados “Universe”, es necesario verificar que esos
repositorios están agregados. En caso que no esté se debe agregar, en nuestro caso particular, sí estaba. Luego se instalan las dependencias:

\begin{lstlisting}
  cat -etc-apt-sources.list
  sudo apt-get install g++ python python-dev scons zlib1g-dev m4  python-pydot protobuf-compiler git
\end{lstlisting}
 
Luego es necesario clonar el repositorio y compilar el código fuente. 

\begin{lstlisting}
  mkdir ~/repos && cd ~/repos
  git clone https://github.com/gem5/gem5.git
  cd ~/repos/gem5
  scons build/ARM/gem5.opt -j5
\end{lstlisting}

Como se deben realizar simulaciones con un sistema completo, entonces se deben descargar las
imágenes que recomiendan los desarrolladores de Gem5. Para los siguientes comandos se supone que el
archivo con las imágenes ha sido descargado en ``~/Downloads/''. 

\begin{lstlisting}
  sudo mkdir /dist/m5/system
  sudo cp ~/Downloads/aarch-system-2014-10.tar.xz .
  sudo tar -xf aarch-system-2014-10.tar.xz
\end{lstlisting}

Una vez completados los pasos anteriores, el sistema está listo para correr simulaciones con Gem5.

\subsection{Escenario A}

\subsubsection{Emulación de Syscall}
Primero se trabaja con el modo de simulación de llamadas a sistema. Para esto se debe ejecutar gem5,
indicarle que se va a utilizar dicha configuración, y además se le proporciona el ejecutable que se
desea ejecutar en la simulación. Para este caso particular, se utiliza el mismo ``hello world'' que se
ofrece de ejemplo simple de prueba. Para eso se utiliza el siguiente comando:

%FIXME: break line
\begin{lstlisting}
  build/ARM/gem5.opt configs/example/se.py -c tests/test-progs/hello/bin/arm/linux/hello
\end{lstlisting}

El código de hello world se ofrece a continuación:

\begin{lstlisting}
  #include <stdio.h>
  int main(){
    printf("Hello world!");
  }
\end{lstlisting}

El resultado de la simulación se muestra en la figura %ref

\begin{figure}[H]
  \centering
  \includegraphics[width=0.5\textwidth]{img/hello_se_gem5_arm.png}
  \caption{\label{fig:se_arm} Simulación SE de hello world en Gem5}
\end{figure}

\subsubsection{Simulación de sistema completo}



\subsection{Escenario B}

\subsection{Escenario C}


\section{Conclusiones}


%----------------------
% Bibliografía
%----------------------

\bibliographystyle{apacite}
\bibliography{bibliografia}

\end{document}
