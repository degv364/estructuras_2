\documentclass {article}

\usepackage[spanish]{babel}
\usepackage [T1]{fontenc}
\usepackage [utf8]{inputenc}
\usepackage {graphicx}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{multirow}

\begin {document}

\title{Tarea1: Simulación de cache}
\author{Daniel García Vaglio B42781, Esteban Zamora Alvarado B47769}

\maketitle


\section{Filtro Gaussiano}

El filtro gausiano es un filtro cuya respuesta al impulso es una función gaussiana, esta está
definida por (\ref{eq:gauss_fn}). Estos filtros son utilizados para el análisis de imágenes, cuando
se requiere comprimir imágenes, detectar bordes, o eliminar ruido. 

\begin{equation}
  \varphi_{gauss}(x)=ae^{-\frac{(x-n)^2}{2x^2}}
\label{eq:gauss_fn}
\end{equation}



\section{Implementación}

El programa adjunto computa imágenes filtradas, utilizando un filtro gaussiano, a partir de imágenes
fuente. Además realiza análisis automáticos del ``speedup'' debido a la paralelización del
algoritmo. Para cargar las imágenes se utilizan funcionalidades de OpenCV. Cabe destacar que OpenCV
solo se utiliza para cargar las imágenes y para mostrar los resultados, no se utiliza para hacer el
filtrado, sino que el filtrado fue desarrollado enteramente por los estudiantes.

\subsection{Image wraper}
OpenCV para C++ ofrece una clase llamada Mat que carga imágenes de distintos formatos como una
matriz $nxm$ (resolución en píxeles), donde cada entrada es un vector tridimensional donde se
codifica el color (formato RGB). Para facilitar el manejo de esta clase, se crea un clase que
funciona como interfaz de Mat. Esta se llama \textit{Image\_wrapper}. Para accesar a una celda de la
matriz, OpenCV primero indexa la columna y luego la fila, esto no es el método natural, entonces
Image\_wrapper hace los ajustes necesarios para que la imagen se recorra con fila columna.

El filtro graussiano funciona haciendo cálculos en lo que se conoce como una ventana. Para cada
píxel se debe calcular un nuevo valor (el valor filtrado). Este valor depende, en teoría, de todos
los píxeles de la imagen, pero dependiendo de la desviación estándar requerida, los pixeles muy
lejanos no tienen un aporte perceptible al nuevo valor. Entonces es posible no tomarlos en cuenta en
los cálculos para acelerar el proceso, pero que el resultado final siga siendo el mismo. El conjunto
de píxeles cercanos es conocido como ventana, y usualmente tiene una forma cuadrada. Se implementa
una clase llamada \textit{neighbor}, que es una abstracción de la ventana. Esta clase calcula el
nuevo valor (valor filtrado) del píxel en su centro, tomando en cuenta todos los píxeles dentro del
``vecindario'', además detecta cuando
se encuentra cerca de los bordes de la imagen y se ajusta para no pedir valores inválidos en sus
cálculos.

\subsection{Algorítmo del filtro}

Para calcular la imagen filtrada, se itera por cada uno de los pixeles (puede que en threads
distintos) y se calcula el nuevo valor dados los pixeles en el ``vecindario''. Se definen dos
imágenes, una es la imagen fuente, o source. Esta es una imagen de solo lectura. Y está la imagen de
escritura, que es donde se guardan los valores nuevos. Esto se hace así para que conforme se van
cambiando los valores de los píxeles, estos cambios no afecten los nuevos cálculos, sino que los
valores filtrados se calculen todos con base en la imagen original. Sea $\sigma$ la desviación
estándar requerida. Y la función de Gauss bidimensional se define por (\ref{eq:bidiGauss}).

\begin{equation}
  \varphi (x, y)= \frac{e^{-(x^2+y^2)/\sigma^2}}{2\pi \sigma^2} 
  \label{eq:bidiGauss}
\end{equation}

En la sección \ref{sec:pseudocodePixel}, se muestra el pseudocódigo para obtener el nuevo valor en
el pixel en la posición $(c_x, c_y)$. Este algoritmo se repite para cada pixel. La ejecución de este
algoritmo se reparte en los threads de ejecución, para poder correrlo en paralelo, sin embargo esta
repartición  se explica más adelante.


\subsubsection{Pseudocódigo para obtener nuevo valor en un píxel}
\label{sec:pseudocodePixel}
\begin{lstlisting}[escapeinside={<}{>}]
  //imagen fuente
  source
  //imagen de escritura
  target
  ng = source.neighbor(<$c_x, c_y$>) //vecindario centrado en (<$c_x, c_y$>)
  target[<$c_x,c_y$>]=(0,0,0)
  for <$x$> in range(ng.x_start, ng.x_end):
     for <$y$> in range(ng.y_start, ng.y_end):
        <$d_x$>=<$x-c_x$> //distancia en x
        <$d_y$>=<$y-c_y$>
        gauss_val=<$\varphi(d_x, d_y)$> //calcular la funcion de gauss
        total+=gauss_val
        //calcular valores pesados con gauss
        target[<$c_x,c_y$>].red  +=source[<$x,y$>].red*gauss_val 
        target[<$c_x,c_y$>].green+=source[<$x,y$>].green*gauss_val
        target[<$c_x,c_y$>].blue +=source[<$x,y$>].blue*gauss_val
  target[<$c_x,c_y$>].red   /=total //dividir entre el total
  target[<$c_x,c_y$>].green /=total
  target[<$c_x,c_y$>].blue  /=total
        
\end{lstlisting}

\subsection{Experimentation}

Se tiene un grupo de funciones, que se agrupan como funciones de experimentación. Estas se encargan
de computar, mostrar y analizar los resultados de las imágenes filtradas a parir de las imágenes
fuente. De ellas la más importante es la función \textit{experiment}, que es la que se encarga de
aplicar el algoritmo de filtrado en paralelo.


\section{Pruebas realizadas}

\section{Resultados experimentales}


\end{document}
