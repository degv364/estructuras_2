\documentclass {article}

\usepackage[spanish]{babel}
\usepackage [T1]{fontenc}
\usepackage [utf8]{inputenc}
\usepackage {graphicx}
\usepackage{color}
\usepackage{xcolor}
\usepackage{verbatim}
\usepackage{tabls}
\usepackage[space]{grffile}
\usepackage{url}
\usepackage{float}
\usepackage{listingsutf8}
\usepackage[justification=centering]{caption}
\usepackage{multirow}

\lstset{language=C++,
  frame=single,
  basicstyle=\ttfamily\small,
  keywordstyle=\color{blue}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  commentstyle=\color[rgb]{0,0.5,0}\ttfamily,
  morecomment=[l][\color{magenta}]{\#},
  literate=%
  {á}{{\'a}}1
  {í}{{\'i}}1
  {é}{{\'e}}1
  {ó}{{\'o}}1
  {ú}{{\'u}}1
  {ñ}{{\~n}}1
}


\begin {document}

\title{Tarea2: Ejecuci\'on de un Filtro Gaussiano en Paralelo}
\author{Daniel García Vaglio B42781, Esteban Zamora Alvarado B47769}

\maketitle

\section{Ejecución en paralelo}

La ejecución en paralelo se refiere a la ejecución de un mismo programa en varios cores, donde
se reparten los recursos y tareas entre los cores, de manera que la ejecución suceda al mismo
tiempo. %FIXME: encontrar cita para definicion de ejecucion en paralelo
Esta técnica se utiliza  usualmente para acelerar procesos que son computacionalmente intensivos, ya
que las tareas se reparten entre varios cores, y no se ejecutan todas en uno solo. No se debe
confundir el término con ejecución concurrente. %FIXME: cita apra paralelo vs concurrente
La ejecución concurrente se refiere a ejecutar varios programas al mismo tiempo, y que se comunican
entre ellos de alguna manera, pero no necesariamente se necesita que todos los programas tengan el
mismo fin.

\subsection{Datos e instrucciones}
Se puede hacer la distinción entre paralelismo a nivel de instrucciones y paralelismo a nivel de
datos.

\section{Threads y Procesos}

Existen dos maneras de lograr la paralelización, una es utilizar threads o hilos, y la otra es
utilizar procesos. Paralelización multiproceso se refiere a que cada core se encarga de un (o varios) procesos
independientes. Los procesos tienen su propio sector de memoria, y al terminar su ejecución retornan
al proceso que los llamó. %FIXME: cita

Por otra parte, los threads son ejecuciones en paralelo, en distintos cores, pero que pertenecen al
mismo proceso. Como no se crean procesos distintos, entonces todos los threads comparten el mismo
sector de memoria. %FIXME: cita

Esta memoria compartida permite una mayor eficiencia, ya que los threads pueden
accesar a los datos ya disponibles. Sin embargo es sumamente riesgoso, porque todos los
threads pueden escribir en las mismas posiciones, y si no se toman precauciones, se pueden tener
comportamientos indeterminados. Por otra parte los procesos son mucho más seguros, pues no comparten
memoria, pero esto hace que si algún proceso necesita los datos de otro, deba pasarlos por medio de
un protocolo de mensajes, lo que lo hace más ineficiente.

Por otra parte, los procesos hijos pueden ejecutarse aún sin el proceso padre, pero los threads
únicamente existen dentro de un proceso. Entonces en caso que hayan errores, los threads ofrecen más
seguridad en el sentido que se terminan todas las ejecuciones, pero los procesos pueden quedar huérfanos y
continuar ocupando recursos, aún cuando el proceso principal ya haya terminado.

En el caso particular de esta aplicación se utilizan threads, porque ofrecen una mayor eficiencia a
nivel de uso de memoria. Además como se va a explicar en las siguientes secciones, los datos se
pueden separar fácilmente entre los threads, de manera que ellos nunca traten de accesar posiciones
comunes. Más adelante se explica con más detalle, pero en general se toman imágenes y a cada thread
se le asigna un sector distinto (exclusivo), entonces no existen riesgos, por escrituras
conflictivas. 


\section{Filtro Gaussiano}

El filtro gausiano es un filtro cuya respuesta al impulso es una función gaussiana, la cual está
definida por (\ref{eq:gauss_fn}). Dentro de las principales aplicaciones de los filtros gaussianos
se encuentra el procesamiento de imágenes con el fin de atenuar ruido. 

\begin{equation}
  \varphi_{gauss}(x)=ae^{-\frac{(x-n)^2}{2x^2}}
  \label{eq:gauss_fn}
\end{equation}

Estos filtros se suelen utilizar como una etapa de previa a los algoritmos de detección de bordes,
los cuales son muy susceptibles a detectar partículas de ruido como parte de los bordes en una
imagen. Por ejemplo, en la figura \ref{fig:canny} se puede ver el resultado de aplicar un algoritmo
de detección que utiliza un filtro gaussiano como preprocesamiento. En este se puede ver que al
modificar la desviación estándar del filtro ($\sigma$) se modifica el detalle de los bordes, lo cual
permite enfocarse en rasgos más o menos detallados según se requiera.

\begin{figure}[ht]
  \centering
  \includegraphics[width=\textwidth]{./img/canny} %FIXME: agragar cita
  \caption{\label{fig:canny}Ejemplo de detección de bordes con diferentes parámetros \\del filtro gaussiano}
\end{figure}




\section{Implementación}

El programa adjunto computa imágenes filtradas, utilizando un filtro gaussiano, a partir de imágenes

fuente. Además realiza análisis automáticos del tiempo de ejecución y ``speedup'' para las
diferentes pruebas paralelizadas. Para cargar las imágenes se utilizan funcionalidades de
OpenCV. %FIXME: agregar cita
Cabe destacar que OpenCV solo se utiliza para cargar las imágenes y para mostrar los
resultados, no se utiliza para hacer el filtrado, sino que el mismo fue desarrollado enteramente por
el algoritmo implementado.


\subsection{Clase Image\_wraper}
OpenCV para C++ ofrece una clase llamada Mat que carga imágenes de distintos formatos como una
matriz $n$ x $m$ (resolución en píxeles), en donde cada entrada es un vector tridimensional donde se
codifica el color (formato RGB). Para facilitar el manejo de esta clase, se crea un clase que
funciona como interfaz de Mat. Esta se llama \textit{Image\_wrapper}. Para accesar a una celda de la
matriz, OpenCV primero indexa la columna y luego la fila, esto no es el método natural, entonces
Image\_wrapper hace los ajustes necesarios para que la imagen se recorra con fila columna.


\subsection{Clase Neighborhood}
El filtro graussiano opera haciendo cálculos en lo que se conoce como una ventana, la cual
corresponde a un conjunto de píxeles cercanos al píxel de interés, y usualmente tiene una forma
cuadrada. Para cada píxel se debe calcular un nuevo valor (el valor filtrado), aplicando la función
del filtro sobre dicha ventana o vecindario.

Se implementa una clase llamada \textit{neighborhood}, que consiste en una abstracción de la
ventana. Esta clase calcula el nuevo valor (valor filtrado) del píxel en su centro, tomando en
cuenta todos los píxeles dentro del ``vecindario'', además detecta cuando se encuentra cerca de los
bordes de la imagen y se ajusta para no accesar valores inválidos en sus cálculos (fuera de la
imagen).

\subsection{Algoritmo del filtro gaussiano}

Para calcular la imagen filtrada, se itera por cada uno de los pixeles (puede que en threads
distintos) y se calcula el nuevo valor dados los pixeles en el ``vecindario''. Se definen dos
imágenes, una es la imagen fuente o source, la cual es de solo lectura. Y está la imagen de
escritura, que es donde se guardan los valores nuevos. Esto se hace así para que conforme se van
cambiando los valores de los píxeles, estos cambios no afecten los nuevos cálculos, sino que los
valores filtrados se calculen todos con base en la imagen original. Sea $\sigma$ la desviación
estándar requerida, la función de Gauss bidimensional utilizada para el filtrado de la imagen se
define entonces por (\ref{eq:bidiGauss}).

\begin{equation}
  \varphi (x, y)= \frac{e^{-(x^2+y^2)/\sigma^2}}{2\pi \sigma^2} 
  \label{eq:bidiGauss}
\end{equation}

En la sección \ref{sec:pseudocodePixel}, se muestra el pseudocódigo del algoritmo utilizado para
obtener el nuevo valor en el pixel en la posición $(c_x, c_y)$, lo cual se repite para cada pixel de
la iamgen. La ejecución de este algoritmo se reparte en los threads de ejecución, para poder
correrlo en paralelo, sin embargo, esta repartición se explica más adelante.

La función \textit{gaussian\_filter} recibe como parámetro dos imagenes. Una de ellas es la de solo
elctura, y la otra es en la que se guarda el resultado. También recibe como parámetro la desviación
estándar, que se necesita para realizar los cómputos de los nuevos valores filtrados. Los últimos
dos parámetros son los que permiten la paralelización a nivel de datos del algoritmo. Ya que indican
el número de columna de inicio, y el número de columna de fin. Entonces esta función solo va a
escribir a partir de la columna de inicio, todas las fials, hasta la columna de final. Se hace por
columnas, porque a lo interno OpenCV utiliza las filas como columnas, eso implica que los datos
están continuos en las columnas del \textit{Image\_wrapper}, lo que incrementa el desempeño de la
aplicación.  


\subsubsection{Pseudocódigo para obtener nuevo valor en un píxel}
\label{sec:pseudocodePixel}

\begin{lstlisting}[escapeinside={<}{>}]
  //imagen fuente
  source
  //imagen de escritura
  target
  //vecindario centrado en (<$c_x, c_y$>)
  ng = source.neighborhood(<$c_x, c_y$>) 
  //valor nuevo por calcular
  target[<$c_x,c_y$>] = (0,0,0)

  for <$x$> in range(ng.x_start, ng.x_end):
     for <$y$> in range(ng.y_start, ng.y_end):
        <$d_x$> = <$x-c_x$> //distancia en x
        <$d_y$> = <$y-c_y$>
        gauss_val = <$\varphi(d_x, d_y)$> //calcular la funcion de gauss
        total+=gauss_val
        //calcular valores parciales con gauss
        target[<$c_x,c_y$>].red  += source[<$x,y$>].red*gauss_val 
        target[<$c_x,c_y$>].green += source[<$x,y$>].green*gauss_val
        target[<$c_x,c_y$>].blue += source[<$x,y$>].blue*gauss_val
  
  target[<$c_x,c_y$>].red   /= total //dividir entre el total
  target[<$c_x,c_y$>].green /= total
  target[<$c_x,c_y$>].blue  /= total
        
\end{lstlisting}

\subsection{Algoritmo paralelizado}
Para paralelizar el algoritmo del filtro gaussiano, se emplearon los \texttt{threads} de la
biblioteca estándar de C++ 11. %FIXME: agregar cita
De esta forma, se utiliza una función denominada
\texttt{gaussian\_filter} en cada thread, a la cual se le indica la región de la imagen sobre la
cual tiene que operar. En particular, la función fue implementada de forma que cada thread se
encarga de calcular el resultado del filtro para una franja vertical de la imagen, cuyo ancho
depende de la cantidad total de threads utilizada. Esto se puede observar en la figura
\ref{fig:image_threads}.


\begin{figure}[ht]
  \centering
  \includegraphics[width=0.6\textwidth]{img/image_threads}
  \caption{\label{fig:image_threads}Repartición de los datos de la imagen en los threads}
\end{figure}

En este sentido se puede afirmar que este algoritmo emplea paralelización a nivel de datos, ya que
se aplica la misma función para distintas secciones de la imagen. A continuación, se muestra el
segmento de código utilizado para implementar la repartición de los datos con los threads. Se puede
ver que los threads se recorren mediante un \texttt{for}, en cuyas iteraciones se va lanzando el
thread correspondiente, con la posición de la franja vertical indicada por el límite inferior
(\texttt{core\_id*interval}) y superior (\texttt{(core\_id+1)*interval}), en el eje x de la imagen.

\begin{lstlisting}[escapeinside={<}{>}]
  
  for (int core<\_>id=0; core<\_>id <<> num<\_>cores; core<\_>id++){
    //Ejecución del filtro gaussiano
    //A cada thread se le asigna una franja de la imagen
    threads[core<\_>id] = thread(<\&>gaussian<\_>filter,
    images[test],
    <\&>control,
    std<\_>dev,
    core<\_>id*interval,
    (core<\_>id+1)*interval);
  }
  //Se espera a que terminen de ejecutarse todos los threads
  for (int core<\_>id=0; core<\_>id < num<\_>cores; core<\_>id++){
    threads[core<\_>id].join();
  }

\end{lstlisting}


\subsection{Experimentation}

Se tiene un grupo de funciones, que se agrupan como funciones de experimentación. Estas se encargan
de computar, mostrar y analizar los resultados de las imágenes filtradas a partir de las imágenes
fuente. De ellas la más importante es la función \textit{experiment}, que es la que se encarga de
aplicar el algoritmo de filtrado en paralelo. Un experimento es computar el filtro gaussiano de una
imagen con distintas cantidades de hilos. 

Recibe como parámetros el índice de la imagen, la
cantidad de cores, el tamaño de la ventana, la desviación estándar, el nombre de la imagen, y
booleanos que indican si se muestran o guardan las imágenes resultantes, también si se comparan los
resultados entre ellos y si se hacen varias ejecuciones donde se va incrementando la cantidad de
cores.

La paralelización se realiza como se explicó con anterioridad. 
En caso de realizarse varias ejecuciones en paralelo (para distintas cantidades de cores), se hace
la repartición de recursos para la cantidad requerida de threads, y se espera a que terminen la
ejecución de todos los hilos. Una vez terminada se vuelve a comenzar el proceso para la siguiente
cantidad de threads


\section{Pruebas realizadas}



\section{Resultados experimentales}



\begin{figure}[ht]
  \centering
  \includegraphics[width=0.9\textwidth]{img/time_multiple_15}
  \caption{Tiempo de ejecución para una cantidad variable de hasta \\15 threads (múltiples
    iteraciones de la prueba)}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.9\textwidth]{img/speedup_multiple_15}
  \caption{Speedup para una cantidad variable de hasta \\15 threads (múltiples iteraciones de la prueba)}
\end{figure}

\begin{figure}[ht]
  \centering
  \includegraphics[width=0.9\textwidth]{img/speedup_single_30}
  \caption{Speedup para una cantidad variable de hasta \\30 threads (una iteración de la prueba)}
\end{figure}




\end{document}
